---
layout: post
published: true
title: Что такое архитектура?
date: '2017-11-23'
tags:
- principles
- software
- naming
- code
---

### Что такое Архитектура?

Все разработчики, с которыми мне приходилось работать, так или иначе упоминали понятие "Архитектура". Хотя это очень размытое понятие, им оперируют почти все. Я долго пытался разобраться сам - что имею ввиду, когда говорю что это часть архитектуры, а это нет.
Статьи на Wikipedia и в некоторых других источниках крайне занудные. Похоже, что понятие довольно старое, и ему не дано четкого определения внутри современных Agile стилей разработки. Но мы попрежнему оперируем им. Поэтому постараюсь дать определение этому понятию в рамках Agile Development Process.

### О чем пишут древние текты

Начнем с того, на чем сходятся все источники: 

* Архитектура это фундаметальные договоренности и решения
* Архитектура это нечто важное
* Архитектуру сложно менять
* Архитектура должна быть использована повторно (в силу своей клевости естественно)

Ну и это пожалуй все. Поверх этого есть много шума о том как именно она должна создаваться и какие есть подходы по ее управлению.
Все эти описания используют такие мудреные слова, что сложно представить подобные процедуры в рамках Agile процессов.
Важная мысль, которая как мне кажется является истоком понятия архитектура это "Архитектурые решения сложно менять" или другими словами "Решения, которые сложно поменять, являются архитектурными". И это действительно то что имеет наибольшее значение. На сколько сложно поменять решение определяет степень его архитектурности. Так же важно, что любое решение легко поменять на следующий день после его принятия или легко поменять решение, которое мало на что влияет. При чем в данном случае "решение" это как програмное решение так и просто договоренность (которая рано или позно все равно закрепляется програмным решением).

### Суть архитектуры

На уровне кода это можно выразить так: как архитектурный код или софт это тот, который используется повторно наибольшее количество раз. При чем это правда как для кода написанного вами лично, так и для когда заимствованого.
Пару примеров: степень архитектурности базы данных это есть количество данных, которые в ней хранятся. Т.е чем больше вы храните данных в этой конкретной базе, тем более архитектурна она для Вас. С другой стороны подключенная к проекту база данных, в которой пока или уже ничего не хранится, архитектурой не является. При этом важно сделать упор именно на то, насколько сложно потом эту базу сменить. Например если вам понадобится поменять MySQL на PostgreSQL, то архитектурность MySQL будет зависить от колличества специфичных ее фич, которые вы использовали. Очень важно отслеживать архитектурность тех или иных решение по мере развития проекта, а не только на его зарождении. В outsource компаниях часто встречается подход, когда в новом проекте приходит важные дядя (например CTO компании) и создает архитектуру, а на следующий день уходит из проекта. Его решения действительно важны, но архитектура им не строится, а строиться теми кто эти решения использует. 
Так возвращаясь к примеру с базой данных, важно отмечать дополнительные завязки на MySQL по мере их появления(если вы используете ORM поверх базы - появляются они как правило не сразу, а намного позже).

### Заложение Архитектуры

Конечно же, в начале любого проекта случается большое колличество архитектурных решений: как хранить данные, какой язык программирования, какой framework?
Но так же важно понять, что все эти решения все еще можно поменять на первых стадиях работы над проектом. И только со временем все эти решения становятся настоящей архтиктурой - той, которую сложно поменять. С этой позиции не все начальные решения покажутся настолько прям архитектурными. Например: выбор языка программирования - явно архитектурное решение, потому что изменение этого решения почти равносильно переписыванию проекта с нуля. А выбор key-value базы данных - не очень фундаментальное решение, поскольку подобных баз данных много и можно заменить одну на другую гораздо легче и незаметнее. Сделать это до выхода проекта в production вообще не составляет особого труда. 

Очень часто в новых проектах доминирует философия "Нам нужно с самого начала сделать все правильно, потому что потом у нас не будет времени что-то менять". Это правда, потому что все время потрачено на то чтобы сделать все правильно, а не на то чтобы делать корректировки по ходу, которые и являются сутью Agile процесса. Так же очень часто важность изначальных решений подкрепляется нежеланием команды и отдельных людей признаваться в неправильности своих решений, ну или хотябы отказа от идеи предсказуемости развития проекта. Agile увы так не работает...
По моему опыту вот список базовых вещей в порядке их важности, которые следует выбрать правильно и потратить на это дополнительное время:

1. Структура хранения данных
2. Язык программирования
3. Development Framework

Все остальное как правило можно поменять или выбрать по ходу с гораздо меньшей отвественностью. Если ваш проект проживет достаточно долго, то рано или поздно все остальное придется менять и адаптировать.

### Заимствованая Архитектура и своя архитектура

Зачастую заимствованые програмные решения гораздо проще поменять, чем свои собственные разработки. Так происходит потому что заимствованый софт совсем ничего не знает о ваших личных целях и задачах. Он решает общие для всего software-community проблемы, которые решены не один раз и похожим способом: поменять одих хостинг на другой будет насравнимо проще чем поменять структуру данных вами же созданную. Создание архитектуры из звоего собственного кода в долгоиграющих проектах очень важна. Она начинается с простого повторного использования кода: кто-то написал класс или метод и кто-то им поспользовался. Архитектурность кода как раз определяется колличеством его повторного использования. Первый хороший звоночек того, что у Вас это получается: если написаный вами метод используют другие члены вашей команды без принуждения к этому. Это говорит о том, что им проще положиться на ваш код как на архитектуру, чем создавать что-то с нуля. 

Все мы знаем насколько программисты любят создавать велосипеды. Причин этому две: очевидная - не умение этих программистов адаптировать существующие решения под свою задачу, и не очевидная - низкое качество кода внутри проекта. Думаю, что каждый из нас был по обе стороны барикады: не хотел использовать код написанный другими и писал код, который другие не хотят использовать. Архитектуру можно построить только если научиться делать и то и другое.

Важную роль в повторном использовании чужого кода играют тесты. Так или иначе при очередном повторном использовании код нужно адаптировать. И именно тесты помогут убедиться, что после адаптации код так же хорошо выполняет старые задачи, как и новые задачи.

### Как же построить свою архитектуру?

* Следить за явными и менее явными дубликациями кода и устранять их сразу
* Искать решения похожих проблем, а не только буквально совпадающих
* Писать тесты
* Адаптировать и обощать старые решения под новые задачи
* Понимать необходимость построения своей собственной архитектуры для этого конкретного проекта как необходимую надстройку над заимствованой
* Не бояться менять и расширять код других членов команды (особенно экс членов команды, кода которых все бояться как огня)
* Уходить в создание чего-либо с нуля при достаточной уверености, что нет абсолютно никаких наработок на эту тему внутри проекта.
* Понимать, что создание архитектуры - непрерывный процесс, а не просто разовая акция по принятию архитектурных решений
* Отслеживать степень завязки проекта на конретные решения по ходу его развития и своевременно их корректировать


