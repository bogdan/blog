<!doctype html>
%html{:lang => "en"}
  %head
    %meta{:charset => "utf-8"}/
    %title How to report a lot?
    %meta{:content => "", :name => "description"}/
    %meta{:content => "Bogdan Gusiev", :name => "author"}/
    %meta{:content => "yes", :name => "apple-mobile-web-app-capable"}/
    %meta{:content => "black-translucent", :name => "apple-mobile-web-app-status-bar-style"}/
    %meta{:content => "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no", :name => "viewport"}/
    %link{:href => "http://lab.hakim.se/reveal-js/css/reveal.css", :rel => "stylesheet"}/
    %link{:href => "http://lab.hakim.se/reveal-js/css/theme/night.css", :rel => "stylesheet"}/
    / For syntax highlighting
    %link{:href => "http://lab.hakim.se/reveal-js/lib/css/zenburn.css", :rel => "stylesheet"}/
    / If the query includes 'print-pdf', use the PDF print sheet
    :javascript
      document.write( '<link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    :sass
      .yellow
        color: yellow
      .reveal
        pre
          code
            padding: 20px 5px
            font-size: 1.00em
            line-height: 1.3em
        ul
          min-width: 50%
        .red
          color: #ff2c2d
        .green
          color: #17ff2e
        .blue
          color: #1b91ff
  %body
    .reveal
      .slides
        %section
          %h1 How To Report a LOT?
          %h3 Bogdan Gusiev
          %h3 May 2015

        %section
          %h1 Report?
        %section
          %h3 Why to Report?
          
          %pre
            %code
              :preserve
                Activity.where(
                  "created_at &gt; ?", 1.day.ago
                ).count # =&gt; ?
        %section
          %h2 At some point
          %h3 You can know about every single event happening in your application every day
          %h2 At another point you can't



        %section
          %h2 a LOT?

          %pre
            %code
              User.that_wants_reporting.count # =&gt; ?

          %h3 At some point you can pull all all requierd number as they are needed
          %h3 At some point you can't

        %section
          %h1 Plan

          %ul
            %li Basic Operations 
            %li Problems as number of metrics growth
            %li What is even a metric?
            %li What is a filter?
            %li Data Model
            %li Live examples


        %section
          %h3 Business speaks with you like this:

          %p Good ones
          %ul
            %li How many new users do we aquire a month at average?
            %li How much sales did we get from this advertising campaign?

          %p And bad ones
          %ul
            %li Please visualise the data.
            %li Can I see how we are performing overall in the last time?

        %section
          %h3 Basic Data Operations in Reporting

          %ul
            %li aggregate (sql: "group by")
            %li filter (sql: "where")
            %li count
            %li sum

        %section
          %h3 The basic model of doing all that

          [you are doing the work in a middle]
        %section
          %h3 Stages

          %ol
            %li At first you learn: SQL, CSV, Graphs, S3 file uploading
            %li Then you feel like an Reporting Machine
            %li And then you say: No thanks...

        %section
          %h3 Let the machine do the work
          %h4 Let you become a software developer again

          [machine in a middle graph]

        %section
          %h2 Requirement to unification and code reuse
          
        %section 
          %h3 Problems:

          %h3 Total Sales = ?
          %pre
            %code
              :preserve
                Purchase.group("month(created_at)").
                  sum(:subtotal)
          %pre.fragment
            %code
              :preserve
                Purchase.group(:marketing_campaign).
                  successfully_delivered.sum(:subtotal)
          %pre.fragment
            %code
              :preserve
                Purchase.
                  group(:marketing_campaign, "month(completed_at)").
                  successfully_delivered.
                  sum(:subtotal)


        %section
          %h3 Does it include a returned sales or not?
          %img{src: "http://monosnap.com/image/8mWPDzrlTJaQEaY9jMR6b9me8yz4zs.png"}

        %section
          %h5 Same metric can be calculated differently in different parts of project

        %section
          %h3 
            Each time person wants to see "Total Sales" there should be only one way of calculating it.
          %h3
            If there is a place where sales number needs to be calculated differently, 
          
          %h2 it should be named differently

        %section
          %h3 "One ring to rule them all!"
            

          %pre
            %code.ruby
              :preserve
                {
                  identifier: 'total_sales',
                  name: 'Total Sales',
                  description: 'Number of successfully delivered sales'
                  how_to_calculate: -> () { 
                    # I'll tell a little later
                  } 
                }



        %section
          %h3 We need to organize aggregation and multiple filters for the same metric:

          %pre
            %code.ruby
              :preserve
                Purchase.where(created_at: ?)

        %section

          %h3 Answer to more advanced queries

          %h4 What is total sales for each marketing campaigns in February?

          %pre
            %code
              :preserve
                Purchase.where(
                  created_at: '2015-02-01'..'2015-03-01'
                ).group(:marketing_campaign).sum(:subtotal)
        %section
          %h4 What is total sales for each week of February in the given marketing campaign?

          %pre
            %code
              :preserve
                Purchase.where(
                  created_at: '2015-02-01'..'2015-03-01', 
                  marketing_campaign: id,
                ).group('week(created_at)').sum(:subtotal)
          
          
          
        %section

          %h3 Compile all requirements and concerns together


        

        %section

          %h2 one query =&gt; one number
          %h2
            %strike
              GROUP BY

        %section
          %pre
            %code
              :preserve
                marketing_campaigns.map do |campaign|
                  total_sales(created_at: february_month, marketing_campaign: campaign)
                end

                weeks_of_february.map do |week|
                  total_sales(created_at: week, marketing_campaign: selected_campaign)
                end

        %section
          %pre
            %code.ruby
              :preserve
                result = []
                marketing_campaigns.each do |campaign|
                  weeks_of_february.each do |week|
                    result &lt;&lt; [ 
                      campaign,
                      week, 
                      total_purchases(created_at: week, marketing_campaign: campaign) 
                      total_sales(created_at: week, marketing_campaign: campaign),
                      new_customers(created_at: week, marketing_campaign: campaign)
                    ]
                  end
                end

        %section

          %table
            %thead
              %tr
                %th Week
                %th
                  Campaign
                %th
                  \# Total Sales
                %th
                  $ Total Sales
                %th New Customers
            %tbody
              - ['1st', '2nd', '3rd'].each do |week|
                - ['SF 15Q1 SA', 'SF 25Q2 PP '].each do |cmp|
                  %tr
                    %td=week
                    %td
                      %nobr= cmp
                    %td
                      = a = rand(1000)
                    %td= "$#{((a * rand(3)/100) +1).to_i},#{100+ rand(900)}.#{rand(100)}"
                    %td 
                      = (a * 0.8).to_i
        %section

          %h3 Introduce object oriented design

          %pre
            %code.ruby
              :preserve
                class ApplicationMetrics
                  def initialize(filters)
                    @filters = filters
                  end

                  def purchases_scope
                    Purchases.successfully_delivered.
                      where(delivered_at: @filters[:period]).
                      where(marketing_campaign_id: @filters[:marketing_campaign])
                  end

                  def total_sales
                    purchases_scope.sum(:subtotal)
                  end
                  def total_purchases
                    purchases_scope.count
                  end
                  def new_customers
                    purchases_scope.count("DISTINCT user_id")
                  end
        %section

          %h3 Advantages

          %ul
            %li Any report aggregation and combination possible
            %li SQL is kept simple: code is easier to write
            %li All numbers across all your project are consistent
            %li Single point of control
            %li Better code reuse: You never start new report from scratch
            %li Front-end is now decoupled from back-end

        %section
          %h3 Disadvantages

          %h2 Performance is going down

        %section
          
          %h2 Cache is unmaintainable

          %h3 10 * 1095 * 20 * 10 &asymp; 2_000_000 variants
          %h3 Exponential growth
          %h3 There are more numbers you can generate than data in your database

        %section
          %h3 Caching in reporting

          %ul
            %li 10 marking campaigns
            %li 3 years = 1095 days
            %li 20 product categories
            %li 10 metrics

        %section
          %h3 Fighting performance concerns
          %ul
            %li Better to get accurate numbers slowly than random numbers fast
            %li Unlike "GROUP BY" this technique is easier to parallelize
            %li You are still not using SSD hard drive or what?

        %section
          %h3 Simplified Terminology

          %ul
            %li Filter
            %li Metric
            %li 
              Operations
              %ul
                %li count
                %li count + distinct
                %li sum
                %li average


              

          
    %script{:src => "http://lab.hakim.se/reveal-js/lib/js/head.min.js"}
    %script{:src => "http://lab.hakim.se/reveal-js/js/reveal.js"}
    :javascript
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      	controls: true,
      	progress: true,
      	history: true,
      	center: true,

      	theme: Reveal.getQueryHash().theme || 'simple', // available themes are in /css/theme
      	transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

      	// Optional libraries used to extend on reveal.js
      	dependencies: [
      		// { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      		{ src: 'http://lab.hakim.se/reveal-js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      		{ src: 'http://lab.hakim.se/reveal-js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      		{ src: 'http://lab.hakim.se/reveal-js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      		// { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      		// { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      		// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
      		// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
      	]
      });
